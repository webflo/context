<?php
// $Id$

define('CONTEXT_UI_DISABLED', 0);
define('CONTEXT_UI_ENABLED', 1);

define('CONTEXT_UI_DEFAULT', 0);
define('CONTEXT_UI_OVERRIDDEN', 1);
define('CONTEXT_UI_USER', 2);

/**
 * Implementation of hook_init().
 */
function context_ui_init() {
  // context_ui integration against the sitewide setter
  context_ui_set('sitewide', 1);

  // context_ui integration against paths
  $path = array();
  $path['real'] = $_GET['q'];
  $path['alias'] = drupal_get_path_alias($_GET['q']);
  if ($path['real'] == $path['alias']) {
    unset($path['alias']);
  }
  // Test each path option incrementally adding args
  // as we go.
  foreach ($path as $path_option) {
    $args = explode('/', $path_option);
    if (count($args)) {
      $test = array_shift($args);
      context_ui_set('path', $test);
      while (count($args)) {
        $test .= '/'. array_shift($args);
        context_ui_set('path', $test);
      }
    }
  }
}

/**
 * Implementation of hook_flush_caches().
 */
function context_ui_flush_caches() {
  context_ui_invalidate_cache();
  return array();
}

/**
 * Implementation of hook_theme().
 */
function context_ui_theme() {
  $items['context_ui_export_form'] = array(
    'arguments' => array('form' => array()),
    'file' => 'context_ui_admin.inc',
  );
  $items['context_ui_item_display'] = array(
    'arguments' => array('form' => array()),
    'file' => 'context_ui_admin.inc',
  );
  $items['context_ui_form'] = array(
    'arguments' => array('form' => array()),
    'file' => 'context_ui_admin.inc',
  );
  $items['context_ui_block_ui'] = array(
    'arguments' => array('form' => array()),
    'file' => 'context_ui_admin.inc',
  );
  $items['context_ui_admin'] = array(
    'arguments' => array('form' => array()),
    'file' => 'context_ui_admin.inc',
  );
  $items['context_devel'] = array(
    'arguments' => array('form' => array()),
  );
  $items['context_devel_recurse'] = array(
    'arguments' => array('form' => array()),
  );
  $items['context_ui_links'] = array(
    'arguments' => array('links' => NULL, 'attributes' => array('class' => 'links')),
  );
  $items['context_ui_menu_links'] = array(
    'arguments' => array('links' => NULL, 'attributes' => array('class' => 'links')),
  );
  $items['context_ui_node_links'] = array(
    'arguments' => array(),
  );
  return $items;
}

/**
 * Implementation of hook_theme_registry_alter().
 */
function context_ui_theme_registry_alter(&$theme_registry) {
  // Push theme_page() through a context_ui_preprocess to provide
  // context-sensitive menus and variables.
  if (!in_array('context_ui_preprocess_page', $theme_registry['page']['preprocess functions'])) {
    $theme_registry['page']['preprocess functions'][] = 'context_ui_preprocess_page';
  }
  // Reroute theme_blocks() through context_ui_blocks to determine block
  // visibility by context.
  unset($theme_registry['blocks']['preprocess functions']);
  $theme_registry['blocks']['function'] = 'context_ui_blocks';
}

/**
 * Implementation of hook_block().
 */
function context_ui_block($op = 'list', $delta = 0, $edit = array()) {
  switch ($op) {
    case 'list':
      $blocks = array();
      $blocks['devel']['info'] = t('Context Devel');
      return $blocks;
    case 'view':
      switch ($delta) {
        case 'devel':
          $block = array();
          $block['subject'] = t('Context Devel');
          if ($context = context_get()) {
            $output = theme('context_devel', $context);
            $block['content'] = $output;
          }
          else {
            $block['content'] = "<p>". t('No context information is set.') ."</p>";
          }
          return $block;
      }
      break;
  }
}

/**
 * Implementation of hook_context_ui_setters().
 *
 * Allows modules to integrate with context_ui and provide their native
 * objects as options for setting a context definition. The
 * hook should return an array of items keyed on the object "type"
 * (e.g. "node", "user", etc.) with key-value pairs corresponding to
 * a FormAPI element array with some restrictions and additional info.
 *
 * '#title': Required. The title of the object / form option.
 * '#type': Required. The FormAPI element type to use. Currently only
 *   'select', 'checkboxes', 'radio', and 'textfield' are allowed.
 * '#description': Optional. Help text to be displayed on the form.
 * '#options': Required. A key-value array of options. They key will be
 *   stored and passed to context_ui_set(), so the integrating module
 *   should use a unique (within its namespace) / usable identifier.
 */
function context_ui_context_ui_setters() {
  $items = array();

  // Content Types
  $nodetypes = array();
  foreach (node_get_types() as $type) {
    $nodetypes[$type->type] = t(drupal_ucfirst($type->name));
  }
  $items['node'] = array(
    '#title' => t('Content Types'),
    '#description' => t('Set this context when viewing a node page or using the add/edit form of one of these content types.'),
    '#options' => $nodetypes,
    '#type' => 'checkboxes',
  );

  // User
  $items['user'] = array(
    '#title' => t('User Pages'),
    '#description' => t('Set this context when a user with selected role(s) is viewed'),
    '#options' => user_roles(true),
    '#type' => 'checkboxes',
  );

  // Book
  if (module_exists('book')) {
    $options = array();
    foreach(book_get_books() as $book) {
      $options[$book['menu_name']] = $book['title'];
    }
    $items['book'] = array(
      '#title' => t('Book'),
      '#description' => t('Set this context when a node in the selected book is viewed.'),
      '#options' => $options,
      '#type' => 'checkboxes',
    );
  }

  // Sitewide context
  $items['sitewide'] = array(
    '#title' => t('Sitewide context'),
    '#type' => 'radios',
    '#options' => array(0 => t('False'), 1 => t('True')),
    '#description' => t('Should this context always be set? If <strong>true</strong>, this context will be active across your entire site.'),
  );

  // Path
  $items['path'] = array(
    '#title' => t('Path'),
    '#description' => t('Set this context when any of the paths above match the beginning or all of the page path. Put each path on a separate line.'),
    '#type' => 'textarea',
    '#element_validate' => array('context_ui_setter_text_validate'),
  );

  return $items;
}

/**
 * Element validate handler for setter textareas and texfields.
 * Will process and convert a string to an array of matchable
 * elements by splitting on an appropriate delimiter ("\n" for
 * textareas and "," for textfields).
 */
function context_ui_setter_text_validate($element, &$form_state) {
  if (!empty($element['#value']) && in_array($element['#type'], array('textfield', 'textarea'))) {
    switch ($element['#type']) {
      case 'textfield':
        $delimiter = ',';
        break;
      case 'textarea':
        $delimiter = "\n";
        break;
    }

    $items = $element['#value'];
    $items = explode($delimiter, $items);

    if (!empty($items)) {
      $values = array();
      foreach ($items as $k => $v) {
        $v = trim($v);
        if (!empty($v)) {
          $values[$v] = TRUE;
        }
      }
      $id = end($element['#parents']);
      $form_state['values']['items'][$id] = $values;
    }
  }
}

/**
 * Implementation of hook_context_getters().
 *
 * Allows modules to integrate with context_ui and provide options for
 * responding when a context has been set. The hook should return an
 * array of items keyed on the "type" of getter (e.g. "menu", "theme",
 * etc.) with key-value pairs corresponding to a FormAPI element array
 * with some restrictions and additional info.
 * 
 * The getter element array provided differs from the setter array in
 * that it may store a tree of values (i.e. where #tree => true). The
 * values will be stored in a serialized array in the database.
 *
 * '#title': Required. The title of the object / form option.
 * '#type': Required. The FormAPI element type to use. Currently only
 *   'select', 'checkboxes', 'radio', and 'textfield' are allowed.
 * '#description': Optional. Help text to be displayed on the form.
 * '#options': Required. A key-value array of options. They key will be
 *   stored and passed to context_ui_set(), so the integrating module
 *   should use a unique (within its namespace) / usable identifier.
 */
function context_ui_context_ui_getters() {
  $items = array();

  // Menu
  if (module_exists('menu')) {
    $menus = menu_parent_options(array_reverse(menu_get_menus()), NULL);
    foreach ($menus as $key => $name) {
      $id = explode(':', $key);
      // @TODO: choose a good convention for excluding root menus from
      // being selectable items
      if ($id[1] == '0') {
        // this is required because root menu names are displayed inside <> and will not be displayed otherwise
        $menus['_'. $key] = '<strong>'. check_plain($name) .'</strong>';
      }
      else {
        $link = menu_link_load($id[1]);
        $menus[$link['link_path']] = $name;
      }
      unset($menus[$key]);
    }
    array_unshift($menus, '<strong>&lt;'. t('None') .'&gt;</strong>');
    $items['menu'] = array(
      '#title' => t('Menus'),
      '#description' => t('Display the selected menu item as active when this context is set. To use this feature, you must use <strong>theme_context_ui_links()</strong> to theme your links. Please see README.txt for more information.'),
      '#options' => $menus,
      '#type' => 'radios',
    );
  }

  // Implements context-based theme improvements
  $items['theme_section'] = array(
    '#tree' => true,
    '#title' => t('Section info'),
    'title' => array(
      '#title' => t('Section title'),
      '#description' => t('Provides this text as a <strong>$section_title</strong> variable for display in page.tpl.php when this context is active.'),
      '#type' => 'textfield',
      '#maxlength' => 255,
    ),
    'subtitle' => array(
      '#title' => t('Section subtitle'),
      '#description' => t('Provides this text as a <strong>$section_subtitle</strong> variable for display in page.tpl.php when this context is active.'),
      '#type' => 'textfield',
      '#maxlength' => 255,
    ),
    'class' => array(
      '#title' => t('Section class'),
      '#description' => t('Provides this text as an additional body class (in <strong>$body_classes</strong> in page.tpl.php) when this section is active. Note that there may only be <strong>one</strong> active section class at once.'),
      '#type' => 'textfield',
      '#maxlength' => 64,
    ),
  );

  // Implements context-based region disabling
  $theme_key = variable_get('theme_default', 'garland');
  $regions = system_region_list($theme_key);
  $items['theme_regiontoggle'] = array(
    '#title' => t('Disabled regions'),
    '#type' => 'checkboxes',
    '#options' => $regions,
  );

  return $items;
}

/**
 * Implementation of hook_menu().
 */
function context_ui_menu() {
  $items['admin/build/context'] = array(
    'title' => 'Context',
    'description' => 'Associate menus, views, blocks, etc. with different contexts to structure your site.',
    'page callback' => 'context_ui_admin',
    'type' => MENU_NORMAL_ITEM,
  );
  $items['admin/build/context/list'] = array(
    'title' => 'List',
    'page callback' => 'context_ui_admin',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => 0,
  );
  $items['admin/build/context/add'] = array(
    'title' => 'Add',
    'description' => 'Add a context to your site.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('context_ui_form', 'add'),
    'type' => MENU_LOCAL_TASK,
    'weight' => 1,
  );
  $items['admin/build/context/import'] = array(
    'title' => 'Import',
    'description' => 'Import a context definition into your site.',
    'page callback' => 'context_ui_import_page',
    'type' => MENU_LOCAL_TASK,
    'weight' => 2,
  );
  $items['admin/build/context/%context_ui_menu'] = array(
    'page callback' => 'drupal_get_form',
    'page arguments' => array('context_ui_form', 'edit', 3),
    'type' => MENU_CALLBACK,
  );
  $items['admin/build/context/%context_ui_menu/edit'] = array(
    'title' => t('Edit'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('context_ui_form', 'edit', 3),
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -1,
  );
  $items['admin/build/context/%context_ui_menu/edit/items'] = array(
    'title' => t('Core attributes'),
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );
  $items['admin/build/context/%context_ui_menu/clone'] = array(
    'title' => t('Clone'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('context_ui_form', 'clone', 3),
    'type' => MENU_LOCAL_TASK,
  );
  $items['admin/build/context/%context_ui_menu/export'] = array(
    'title' => t('Export'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('context_ui_export', 3),
    'type' => MENU_LOCAL_TASK,
  );
  $items['admin/build/context/%context_ui_menu/delete'] = array(
    'title' => t('Delete'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('context_ui_confirm', 'delete', 3),
    'type' => MENU_LOCAL_TASK,
  );
  $items['admin/build/context/%context_ui_menu/disable'] = array(
    'title' => t('Disable'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('context_ui_confirm', 'disable', 3),
    'type' => MENU_LOCAL_TASK,
  );
  $items['admin/build/context/%context_ui_menu/enable'] = array(
    'title' => t('Enable'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('context_ui_confirm', 'enable', 3),
    'type' => MENU_LOCAL_TASK,
  );
  foreach ($items as $path => $item) {
    $items[$path]['access callback'] = 'user_access';
    $items[$path]['access arguments'] = array('administer site configuration');
    $items[$path]['file'] = 'context_ui_admin.inc';
  }
  return $items;
}

/**
 * Helper loader to parse menu arguments and load contexts accordingly.
 */
function context_ui_menu_load($arg) {
  if (is_numeric($arg)) {
    return context_ui_load($arg);
  }
  else {
    $contexts = context_ui_contexts();
    if (!empty($contexts[$arg])) {
      return $contexts[$arg];
    }
  }
}

/**
 * Implementation of hook_help().
 */
function context_ui_help($path, $arg) {
  switch ($path) {
    case 'admin/build/context':
      return '<p>'.
        t('Contexts provide you with a way to organize your site using terms familiar to real human beings. You can create a set of sections like <b>"News"</b>, <b>"Projects"</b>, <b>"Staff"</b>, and associate different technical aspects of Drupal to each section. For example, the <b>"News"</b> section may be a collection of <b>Nodes</b>, <b>Views</b>, <b>Menus</b> and <b>Blocks</b>.')
        .'</p>';
      break;
  }
}

/**
 * Implementation of hook_nodeapi().
 */
function context_ui_nodeapi(&$node, $op, $teaser, $page) {
  if ($op == 'view' && $page && menu_get_object() === $node) {
    // Implementation of context_ui_set for node.
    context_ui_set('node', $node->type);

    // Implementation of context_ui_set for book.
    if (module_exists('book') && isset($node->book)) {
      if ($node->book['menu_name']) {
        context_ui_set('book', $node->book['menu_name']);
      }
    }
  }
}

/**
 * Implementation of hook_form_alter().
 */
function context_ui_form_alter(&$form, $form_state, $form_id) {
  if (isset($form['#node']) && arg(0) != 'admin') { // Prevent this from firing on admin pages... damn form driven apis...
    context_ui_set('node', $form['#node']->type);
  }
  if ($form_id == 'system_modules') {
    context_ui_invalidate_cache();
  }
}

/**
 * Implementation of hook_form_alter() for comment_form.
 */
function context_ui_form_comment_form_alter(&$form, $form_state) {
  if ($nid = $form['nid']['#value']) {
    $node = node_load($nid);
    context_ui_set('node', $node->type);
  }
}

/**
 * Implementation of hook_form_alter() for block_admin_configure.
 */
function context_ui_form_block_admin_configure_alter(&$form, $form_state) {
  // Display context_ui visibility information on block configuration pages
  $module = $form['module']['#value'];
  $delta = $form['delta']['#value'];

  $rows = array();

  $contexts = context_ui_enabled_contexts();
  foreach ($contexts as $context) {
    if (!empty($context->block)) {
      foreach ($context->block as $block) {
        // @TODO: normalize this to either an array or object. I apolgize for this sloppy shiz : |
        $block = (object) $block;
        if ($block->module == $module && $block->delta == $delta) {
          $row = array();
          $row[] = $context->namespace;
          $row[] = $context->attribute;
          $row[] = $context->value;
          $row[] = $block->region;          
          $identifier = "{$context->namespace}-{$context->attribute}-{$context->value}";
          $options = array(
            'fragment' => 'context-ui-blocks',
            'query' => 'destination='. $_GET['q'],
          );
          if ($context->system) {            
            $row[] = l(t('Override visibility'), "admin/build/context/$identifier/clone", $options);
          }
          else {
            $row[] = l(t('Edit visibility'), "admin/build/context/{$context->cid}", $options);
          }
          $rows[] = $row;
        }
      }
    }
  }

  if ($rows) {
    $content = theme('table', array(t('Namespace'), t('Attribute'), t('Value'), t('Region'), ''), $rows);
  }
  else {
    $content = "<p>". t('No visibility rules have been set for this block using context_ui.') ."</p>";
  }

  $form['context_ui'] = array(
    '#type' => 'fieldset',
    '#title' => t('Context UI visibility'),
    '#weight' => -1,
    '#collapsible' => true,
  );
  $form['context_ui']['contexts'] = array(
    '#type' => 'item',
    '#value' => $content,
    '#description' => t('To add or remove block visibility rules based on context, use the !context_admin.', array('!context_admin' => l(t('context administration page'), 'admin/build/context'))),
  );
  $form['block_settings']['#weight'] = -5;
}

/**
 * Implementation of hook_user().
 */
function context_ui_user($op, &$edit, &$account, $category = NULL) {
  if ($op == 'view' && !empty($account->roles)) {
    foreach (array_keys($account->roles) as $rid) {
      context_ui_set('user', $rid);
    }
  }
}

/**
 * Invokes hook_context_ui_define() to collect all contexts provided in code by modules.
 *
 * @param $space
 *   An optional string namespace identifier. If provided, only context definitions with the
 *   specified namespace will be returned.
 *
 * @return
 *   An array of context objects.
 */
function context_ui_contexts($reset = FALSE) {
  static $contexts;
  if (!$contexts || $reset) {
    $contexts = array();
    foreach (module_implements('context_ui_define') as $module) {
      $function = $module .'_context_ui_define';
      $c = $function();
      if (!empty($c)) {
        foreach ($c as $context) {
          $context = (object) $context;
          $context->type = CONTEXT_UI_DEFAULT;
          $identifier = "$context->namespace-$context->attribute-$context->value";
          $contexts[$identifier] = $context;
        }
      }
    }
    // Backwards-compatibility support -- this is not hugely detrimental as
    // for most page loads the result of this function is cached.
    // @TODO: will be removed for 1.0 stable release.
    foreach (module_implements('context_define') as $module) {
      drupal_set_message(t('The module <strong>!modulename</strong> is using <em>hook_context_define()</em> which has been renamed to <em>hook_context_ui_define()</em>. Support for this will be dropped soon -- please update your modules.', array('!modulename' => $module)), 'warning');
      $function = $module .'_context_define';
      $c = $function();
      if (!empty($c)) {
        foreach ($c as $context) {
          $context = (object) $context;
          $context->type = CONTEXT_UI_DEFAULT;
          $identifier = "$context->namespace-$context->attribute-$context->value";
          $contexts[$identifier] = $context;
        }
      }
    }
    // Allow other modules to alter contexts
    drupal_alter('context_ui_default_contexts', $contexts);
    foreach ($contexts as $key => $context) {
      $contexts[$key] = $context;
    }

    $result = db_query("SELECT * FROM {context_ui} ORDER BY namespace ASC, attribute ASC, value ASC");
    while ($context = db_fetch_object($result)) {
      if ($context = context_ui_load($context)) {
        $key = "$context->namespace-$context->attribute-$context->value";
        if (isset($contexts[$key])) {
          $contexts[$key] = $context;
          $contexts[$key]->type = CONTEXT_UI_OVERRIDDEN;
        }
        else {
          $contexts[$key] = $context;
          $contexts[$key]->type = CONTEXT_UI_USER;
        }
      }
    }
    foreach ($contexts as $key => $context) {
      $contexts[$key]->status = context_ui_status($context);
    }
  }
  return $contexts;
}

/**
 * Wrapper around cache_get() to make it easier for context to pull different
 * datastores from a single cache row.
 */
function context_ui_cache_get($key, $reset = FALSE) {
  static $cache;
  if (!isset($cache) || $reset) {
    $cache = cache_get('context', 'cache');
    $cache = $cache ? $cache->data : array();
  }
  return !empty($cache[$key]) ? $cache[$key] : FALSE;
}

/**
 * Wrapper around cache_set() to make it easier for context to write different
 * datastores to a single cache row.
 */
function context_ui_cache_set($key, $value) {
  $cache = cache_get('context', 'cache');
  $cache = $cache ? $cache->data : array();
  $cache[$key] = $value;
  cache_set('context', $cache);  
}

/**
 * Retrieves all enabled contexts from the cache.
 */
function context_ui_enabled_contexts($namespace = NULL, $reset = FALSE) {
  static $enabled;
  static $namespaces;
  if (!isset($enabled) || $reset) {
    $enabled = array();
    $cache = context_ui_cache_get('enabled');
    if ($cache && !$reset) {
      $enabled = $cache;
    }
    else {
      $contexts = context_ui_contexts(TRUE);
     
      foreach ($contexts as $context) {
        if (context_ui_status($context) == CONTEXT_UI_ENABLED) {
          $identifier = "$context->namespace-$context->attribute-$context->value";
          $enabled[$identifier] = $context;
        }
      }
     
      // Set the cache
      context_ui_cache_set('enabled', $enabled);
    }
    foreach ($enabled as $identifier => $context) {
      if (!isset($namespaces[$context->namespace])) {
        $namespaces[$context->namespace] = array();
      }
      $namespaces[$context->namespace][$identifier] = $context;
    }
  }

  if (!empty($namespace)) {
    return !empty($namespaces[$namespace]) ? $namespaces[$namespace] : array();
  }
  return $enabled;
}

/**
 * Loads any active contexts with associated getter items. This should be run
 * at a late stage of the page load to ensure that relevant contexts have been set.
 */
function context_ui_active_contexts($reset = FALSE) {
  static $contexts;
  if (!isset($contexts) || $reset) {
    $contexts = array();
    $cache = context_ui_enabled_contexts();
    foreach ($cache as $context) {
      if (context_get($context->namespace, $context->attribute) == $context->value) {
        $identifier = "$context->namespace-$context->attribute-$context->value";
        $contexts[$identifier] = $context;
      }
    }
    drupal_alter('context_ui_active_contexts', $contexts);
  }
  return $contexts;
}

/**
 * Loads an associative array of setters => context identifiers to allow
 * contexts to be set by different setter conditions. Called by context_ui_set().
 */
function context_ui_setter_map($reset = FALSE) {
  static $setter_map;
  if (!isset($setter_map) || $reset) {
    $cache = context_ui_cache_get('setter_map');
    if ($cache && !$reset) {
      $setter_map = $cache;
    }
    else {
      $enabled = context_ui_enabled_contexts();
      foreach (array_keys(context_ui_setters()) as $setter) {
        $setter_map[$setter] = array();
        foreach ($enabled as $identifier => $context) {
          if (!empty($context->{$setter})) {
            if (is_array($context->{$setter})) {
              foreach ($context->{$setter} as $value) {
                if (!isset($setter_map[$setter][$value])) {
                  $setter_map[$setter][$value] = array();
                }
                $setter_map[$setter][$value][] = $identifier;
              }
            }
            else if (is_string($context->{$setter})) {
              $value = $context->{$setter};
              if (!isset($setter_map[$setter][$value])) {
                $setter_map[$setter][$value] = array();
              }
              $setter_map[$setter][$value][] = $identifier;
            }
          }
        }
      }
      context_ui_cache_set('setter_map', $setter_map);
    }
  }
  return $setter_map;
}

/**
 * Returns TRUE or FALSE based on whether a given context definition is enabled.
 */
function context_ui_status($context) {
 $status = variable_get('context_status', array());
 $identifier = "$context->namespace-$context->attribute-$context->value";
  if (isset($status[$identifier]) && !$status[$identifier]) {
    return CONTEXT_UI_DISABLED;
 }
  return CONTEXT_UI_ENABLED;
}

/**
 * Invalidates all context caches().
 */
function context_ui_invalidate_cache() {
  cache_clear_all('context', 'cache');
}

/**
 * Invokes hook_context_ui_setters() to provide an array of setters that may be associated with a context.
 */
function context_ui_setters($reset = FALSE) {
  static $setters;
  if (!isset($setters) || $reset) {
    $cache = context_ui_cache_get('setters');
    if ($cache && !$reset) {
      $setters = $cache;
    }
    else {
      $setters = module_invoke_all('context_ui_setters');
      context_ui_cache_set('setters', $setters);
    }
  }
  return $setters;
}

/**
 * Invokes hook_context_getters() to provide an array of getters that may be associated with a context.
 */
function context_ui_getters($reset = FALSE) {
  static $getters;
  global $theme_key;
  if (!isset($getters) || $reset) {
    $cache = context_ui_cache_get('getters');
    if ($cache && !$reset) {
      $getters = $cache;
    }
    else {
      $getters = module_invoke_all('context_ui_getters');

      // Give theme developers a chance to integrate against context_ui
      if (isset($theme_key)) {
        $function = $theme_key .'_context_ui_getters';
        if (function_exists($function)) {
          $getters = array_merge($getters, $function());
        }
      }
      context_ui_cache_set('getters', $getters);
    }
  }
  return $getters;
}

/**
 * Sets a namespace-attribute-value context that has been associated with the provided item.
 *
 * @param $type
 *   The item type to be matched. Any of the currently supported context items types ("view",
 *   "node", etc.) can be specified.
 * @param $id
 *   A string value to match against.
 *
 * @return
 *   True if one or more contexts were set. False if no items/contexts matched.
 */
function context_ui_set($type, $id) {
  $map = context_ui_setter_map();
  $set = FALSE;
  if (!empty($map[$type]) && !empty($map[$type][$id])) {
    $contexts = context_ui_enabled_contexts(); 

    $identifiers = $map[$type][$id];
    foreach ($identifiers as $identifier) {
      $context = !empty($contexts[$identifier]) ? $contexts[$identifier] : FALSE;

      if ($context) {
        // If this context already has a value, don't alter it.
        if (!context_isset($context->namespace, $context->attribute)) {
          context_set($context->namespace, $context->attribute, $context->value);

          // DEPRECATED @TODO: remove this invocation of hook_context_getter()...
          $identifier = "$context->namespace-$context->attribute-$context->value";
          if (!empty($contexts[$identifier])) {
            $context = $contexts[$identifier];
            // Allow getters to respond to the set context
            module_invoke_all('context_getter', $context);
          }
          $set = TRUE;
        }
      }
    }
  }
  return $set;
}

/**
 * Recursive helper function to determine whether an array and its
 * children are entirely empty.
 */
function context_ui_empty($element) {
  $empty = TRUE;
  if (is_array($element)) {
    foreach ($element as $child) {
      $empty = $empty && context_ui_empty($child);
    }
  }
  else {
    $empty = $empty && empty($element);
  }
  return $empty;
}

/**
 * BLOCK HANDLING =====================================================
 */

/**
 * This override of theme_blocks() is called because of an alter of the
 * theme registry. See context_ui_theme_registry_alter().
 */
function context_ui_blocks($region) {
  $output = "";
  if ($list = context_ui_block_list($region)) {
    foreach ($list as $key => $block) {
      $output .= theme("block", $block);
    }
  }
  // Add any content assigned to this region through drupal_set_content() calls.
  $output .= drupal_get_content($region);
  return $output;
}

/**
 * An alternative version of block_list() that provides any context_ui enabled blocks.
 */
function context_ui_block_list($region) {
  static $blocks;
  static $context_blocks;
  static $disabled_regions;

  if (!isset($context_blocks)) {
    $blocks = array();
    $context_blocks = array();
    $disabled_regions = array();

    // Store all active context blocks when first called
    foreach (context_ui_active_contexts() as $context) {
      if (isset($context->block) && is_array($context->block)) {
        foreach ($context->block as $block) {
          $block = (object) $block;
          $context_blocks["{$block->module}_{$block->delta}"] = $block;
        }
      }
      if (!empty($context->theme_regiontoggle)) {
        foreach ($context->theme_regiontoggle as $r => $enabled) {
          if (!empty($enabled)) {
            $disabled_regions[$r] = $r;
          }
        }
      }
    }

    global $user, $theme_key;
    $rids = array_keys($user->roles);

    // This query is identical to the one in block_list(), but status = 1 is excluded to
    // retain blocks that may be enabled via context.
    $result = db_query(db_rewrite_sql("SELECT DISTINCT b.* FROM {blocks} b LEFT JOIN {blocks_roles} r ON b.module = r.module AND b.delta = r.delta WHERE b.theme = '%s' AND (r.rid IN (". db_placeholders($rids) .") OR r.rid IS NULL) ORDER BY b.region, b.weight, b.module", 'b', 'bid'), array_merge(array($theme_key), $rids));

    while ($block = db_fetch_object($result)) {
      $bid = "{$block->module}_{$block->delta}";

      // If block is not enabled & not enabled via context, skip it
      if (!empty($context_blocks[$bid])) {
        $block->region = $context_blocks[$bid]->region;
        $block->weight = $context_blocks[$bid]->weight;
        $enabled = TRUE;
      }
      else if (!$block->status) {
        continue;
      }

      // Initialize region key
      if (!isset($blocks[$block->region])) {
        $blocks[$block->region] = array();
      }

      // Use the user's block visibility setting, if necessary
      if ($block->custom != 0) {
        if ($user->uid && isset($user->block[$block->module][$block->delta])) {
          $enabled = $user->block[$block->module][$block->delta];
        }
        else {
          $enabled = ($block->custom == 1);
        }
      }
      else {
        $enabled = TRUE;
      }

      // Match path if necessary
      if ($block->pages) {
        if ($block->visibility < 2) {
          $path = drupal_get_path_alias($_GET['q']);
          // Compare with the internal and path alias (if any).
          $page_match = drupal_match_path($path, $block->pages);
          if ($path != $_GET['q']) {
            $page_match = $page_match || drupal_match_path($_GET['q'], $block->pages);
          }
          // When $block->visibility has a value of 0, the block is displayed on
          // all pages except those listed in $block->pages. When set to 1, it
          // is displayed only on those pages listed in $block->pages.
          $page_match = !($block->visibility xor $page_match);
        }
        else {
          $page_match = drupal_eval($block->pages);
        }
      }
      else {
        $page_match = TRUE;
      }

      $block->enabled = $enabled;
      $block->page_match = $page_match;
      $blocks[$block->region]["{$block->module}_{$block->delta}"] = $block;
    }

    // Sort blocks -- we must do this here since blocks provided via
    // context may have overridden or altered weights.
    foreach ($blocks as $r => $dummy) {
      uasort($blocks[$r], '_context_ui_block_sort');
    }
  }

  // Kill blocks in disabled regions
  foreach (array_keys($disabled_regions) as $r) {
    unset($blocks[$r]);
  }

  // ==================================================================
  // The block rendering code below is identical to block_list().
  // ==================================================================

  // Create an empty array if there were no entries
  if (!isset($blocks[$region])) {
    $blocks[$region] = array();
  }

  foreach ($blocks[$region] as $key => $block) {
    // Render the block content if it has not been created already.
    if (!isset($block->content)) {
      // Erase the block from the static array - we'll put it back if it has content.
      unset($blocks[$region][$key]);
      if ($block->enabled && $block->page_match) {
        // Check the current throttle status and see if block should be displayed
        // based on server load.
        if (!($block->throttle && (module_invoke('throttle', 'status') > 0))) {
          // Try fetching the block from cache. Block caching is not compatible with
          // node_access modules. We also preserve the submission of forms in blocks,
          // by fetching from cache only if the request method is 'GET'.
          if (!count(module_implements('node_grants')) && $_SERVER['REQUEST_METHOD'] == 'GET' && ($cid = _block_get_cache_id($block)) && ($cache = cache_get($cid, 'cache_block'))) {
            $array = $cache->data;
          }
          else {
            $array = module_invoke($block->module, 'block', 'view', $block->delta);
            if (isset($cid)) {
              cache_set($cid, $array, 'cache_block', CACHE_TEMPORARY);
            }
          }

          if (isset($array) && is_array($array)) {
            foreach ($array as $k => $v) {
              $block->$k = $v;
            }
          }
        }
        if (isset($block->content) && $block->content) {
          // Override default block title if a custom display title is present.
          if ($block->title) {
            // Check plain here to allow module generated titles to keep any markup.
            $block->subject = $block->title == '<none>' ? '' : check_plain($block->title);
          }
          if (!isset($block->subject)) {
            $block->subject = '';
          }
          $blocks[$block->region]["{$block->module}_{$block->delta}"] = $block;
        }
      }
    }
  }

  return $blocks[$region];
}

/**
 * Helper function to sort blocks.
 */
function _context_ui_block_sort($a, $b) {
  return ($a->weight - $b->weight);
}

/**
 * L'CRUD FUNCTIONS ===================================================
 */

/**
 * Context loader.
 *
 * @param $context
 *   The parameters to use for loading this context. Can be an integer
 *   cid or partial context object.
 *
 * @return
 *   Returns a fully-loaded context definition.
 */
function context_ui_load($context, $reset = FALSE) {
  static $cache = array();
  // Argument is a cid
  if (is_numeric($context)) {    
    $cid = $context;
    if (!isset($normal[$context])) {
      $context = db_fetch_object(db_query("SELECT * FROM {context_ui} WHERE cid = %d", $cid));
    }
    else {
      $context = new StdClass();
      $context->cid = $cid;
    }
  }
  // Context object has an associated cid
  else if (is_object($context) && isset($context->cid)) {
    if (!isset($normal[$context->cid])) {
      $context = db_fetch_object(db_query("SELECT * FROM {context_ui} WHERE cid = %d", $context->cid));
    }
  }
  // Context object has no cid -- we'll try to load by ns/attr/val
  else if (is_object($context) && $context->namespace && $context->attribute && $context->value) {
    $args = array($context->namespace, $context->attribute, $context->value);
    $context = db_fetch_object(db_query("SELECT * FROM {context_ui} WHERE namespace = '%s' AND attribute = '%s' AND value = '%s'", $args));
  }

  // If the cid has been discovered, load all the context's associations.
  if (isset($context->cid)) {
    if (!isset($cache[$context->cid]) || $reset) {
      // Load setters
      $result = db_query("SELECT * FROM {context_ui_setter} WHERE cid = %d", $context->cid);
      while ($row = db_fetch_object($result)) {
        $context->{$row->type}[$row->id] = $row->id;
      }
      // Load getters
      $result = db_query("SELECT * FROM {context_ui_getter} WHERE cid = %d", $context->cid);
      while ($row = db_fetch_object($result)) {
        $context->{$row->type} = unserialize($row->data);
      }
      // Load blocks
      $result = db_query("SELECT module, delta, region, weight FROM {context_ui_block} WHERE cid = %d", $context->cid);      
      while ($block = db_fetch_object($result)) {
        if (!isset($context->block)) {
          $context->block = array();
        }
        $block->bid = $block->module ."_". $block->delta;
        $context->block[$block->bid] = $block;
      }
      // After all that hard work, cache the context
      $cache[$context->cid] = $context;
    }
    return $cache[$context->cid];
  }  
  return false;
}

/**
 * Inserts or updates a context object into the database.
 * @TODO: should probably return the new cid on success -- make sure
 * this doesn't break any checks elsewhere.
 *
 * @param $context
 *   The context object to be inserted.
 *
 * @return
 *   Returns true on success, false on failure.
 */
function context_ui_save($context) {
  // Insert or update the core context definition
  if (!isset($context->cid)) {
    $existing = context_ui_load($context, TRUE);
    if ($existing && $existing->cid) {
      return false;      
    }
    drupal_write_record('context_ui', $context);
  }  
  else {
    drupal_write_record('context_ui', $context, array('cid'));
  }
  
  // Insert or update the associated context items
  $result = TRUE;
  
  // Insert/update setters
  foreach (array_keys(context_ui_setters()) as $type) {
    db_query("DELETE FROM {context_ui_setter} WHERE cid = %d AND type = '%s'", $context->cid, $type);
    if (isset($context->{$type}) && is_array($context->{$type})) {
      foreach ($context->{$type} as $id) {
        $item = new StdClass();
        $item->type = $type;
        $item->id = $id;
        $item->cid = $context->cid;
        drupal_write_record('context_ui_setter', $item);
      }
    }
  }

  // Insert/update getters
  foreach (array_keys(context_ui_getters()) as $type) {
    db_query("DELETE FROM {context_ui_getter} WHERE cid = %d AND type = '%s'", $context->cid, $type);
    if (isset($context->{$type})) {
      $item = new StdClass();
      $item->type = $type;
      $item->data = serialize($context->{$type});
      $item->cid = $context->cid;
      drupal_write_record('context_ui_getter', $item);
    }
  }

  // Insert/update blocks
  db_query("DELETE FROM {context_ui_block} WHERE cid = %d", $context->cid);
  if (isset($context->block) && is_array($context->block)) {
    foreach ($context->block as $block) {
      $block = (object) $block;
      $block->cid = $context->cid;
      drupal_write_record('context_ui_block', $block);
    }
  }

  // Invalidate context cache
  cache_clear_all('context', 'cache');
  return $result;
}

/**
 * Deletes an existing context.
 *
 * @param $context
 *   The context object to be deleted. The $context->cid property is
 *   necessary for this operation.
 *
 * @return
 *   Returns true on success, false on failure.
 */
function context_ui_delete($context) {
  if ($context = context_ui_load($context, TRUE)) {
    db_query("DELETE FROM {context_ui} WHERE cid = %d", $context->cid);
    db_query("DELETE FROM {context_ui_setter} WHERE cid = %d", $context->cid);
    db_query("DELETE FROM {context_ui_getter} WHERE cid = %d", $context->cid);
    db_query("DELETE FROM {context_ui_block} WHERE cid = %d", $context->cid);

    // Invalidate context cache
    cache_clear_all('context', 'cache');

    return true;
  }
  return false;
}

/**
 * THEME FUNCTIONS ====================================================
 */

/**
 * Takes a retrieved context array and returns a themed out tree representation of that context.
 */
function theme_context_devel($context) {
  drupal_add_css(drupal_get_path("module", "context_ui") ."/context_ui.css");
  $output = '';
  foreach ($context as $space => $a) {
    $output .= "<div class='context-devel-space'>$space</div>";
    $output .= "<div class='context-devel-tree'>". theme_context_devel_recurse($a) ."</div>";
  }
  return $output;
}

/**
 * Helper function to theme_context_devel that recurses down context arrays and themes accordingly.
 */
function theme_context_devel_recurse($value) {
  $output = '';
  if (is_array($value) || is_object($value)) {
    if (is_array($value)) {
      $type = 'array';
    }
    else if (is_object($value)) {
      $type = 'object';
    }
    foreach ((array)$value as $key => $a) {
      $output .= "<div class='context-devel-wrapper'><label><small>$type</small>$key</label>". theme('context_devel_recurse', $a) ."</div>";
    }
  }
  else {
    if (is_string($value)) {
      $type = 'string';
    }
    else if (is_int($value)) {
      $type = 'int';
    }
    else if (is_bool($value)) {
      $type = 'bool';
    }
    $output .= "<div class='context-devel-wrapper'><label><small>$type</small>$value</label></div>";
  }
  return $output;
}

/**
 * Generates a themed set of links for node types associated with
 * the current active contexts.
 */
function theme_context_ui_node_links() {
  $output = '';
  $links = _context_ui_node_links();
  foreach ($links as $link) {
    $options = array_merge($link, array('attributes' => array('class' => 'button')));
    if (!empty($link['custom'])) {
      $output .= l($link['title'], $link['href'], $options);
    }
    else {
      $output .= l('+ '. t('Add !type', array('!type' => $link['title'])), $link['href'], $options);
    }
  }
  return $output;
}

/**
 * Generates an array of links (suitable for use with theme_links)
 * to the node forms of types associated with current active contexts.
 */
function _context_ui_node_links($reset = false) {
  static $links;
  if (!$links || $reset) {
    $links = array();
    if ($contexts = context_ui_active_contexts()) {
      // Collect types
      $types = node_get_types();
      // Iterate over active contexts
      foreach ($contexts as $context) {
        if (!empty($context->node)) {
          foreach ($context->node as $type) {
            $type_url = str_replace('_', '-', $type);
            $add_url = 'node/add/'. $type_url;
            if (isset($types[$type]) && strpos($_GET['q'], $add_url) === FALSE && node_access('create', $type)) {
              $links[$type_url] = array('title' => $types[$type]->name, 'href' => $add_url);
            }
          }
        }
      }
    }
    drupal_alter('context_ui_node_links', $links);
  }
  return $links;
}

/**
 * Implementation of preprocess_page().
 */
function context_ui_preprocess_page(&$vars) {
  $info = context_ui_section_info();
  $vars['section_title'] = !empty($info['title']) ? $info['title'] : '';
  $vars['section_subtitle'] = !empty($info['subtitle']) ? $info['subtitle'] : '';
  $vars['body_classes'] .= !empty($info['class']) ? ' '. $info['class'] : '';

  // If primary + secondary links are pointed at the same menu, provide
  // contextual trailing by default.
  if (variable_get('menu_primary_links_source', 'primary-links') == variable_get('menu_secondary_links_source', 'secondary-links')) {
    $vars['primary_links'] = context_ui_menu_navigation_links(variable_get('menu_primary_links_source', 'primary-links'));
    $vars['secondary_links'] = context_ui_menu_navigation_links(variable_get('menu_secondary_links_source', 'secondary-links'), 1);
  }

  $vars['primary_links'] = context_ui_menu_set_active($vars['primary_links']);
  $vars['secondary_links'] = context_ui_menu_set_active($vars['secondary_links']);

  $vars['context_links'] = theme('context_ui_node_links');
}

/**
 * Iterates through a provided links array for use with theme_links()
 * (e.g. from menu_primary_links()) and provides an active class for
 * any items that have a path that matches an active context.
 *
 * @param $links
 *   An array of links.
 * @param $reset
 *   A boolean flag for resetting the static cache.
 *
 * @return
 *   A modified links array.
 */
function context_ui_menu_set_active($links = array(), $reset = FALSE) {
  // Build a list of active paths & static cache it
  static $active_paths;
  if (!isset($active_paths) || $reset) {
    $active_paths = array();
    foreach (context_ui_active_contexts() as $context) {
      if (isset($context->menu)) {
        $active_paths[] = $context->menu;
      }
    }
  }

  // Iterate through the provided links and build a new set of links
  // that includes active classes
  $new_links = array();
  if (!empty($links)) {
    foreach ($links as $key => $link) {
      if (!empty($link['href']) && in_array($link['href'], $active_paths)) {
        if (isset($links['attributes'])) {
          if (isset($links['attributes']['class'])) {
            $link['attributes']['class'] .= ' active';
          }
          else {
            $link['attributes']['class'] = 'active';
          }
        }
        else {
          $link['attributes'] = array('class' => 'active');
        }
        if (strpos(' active', $key) === FALSE) {
          $new_links[$key .' active'] = $link;
        }
      }
      else {
        $new_links[$key] = $link;
      }
    }
  }

  return $new_links;
}

/**
 * Retrieves an array of current section information and static caches it.
 *
 * @param $reset
 *   A boolean flag to reset the static cache.
 *
 * @return
 *   A section title string.
 */
function context_ui_section_info($reset = FALSE) {
  static $info;
  if (!isset($info) || $reset) {
    $info = array();
    foreach (context_ui_active_contexts() as $context) {
      if (isset($context->theme_section)) {
        if (!empty($context->theme_section['title']) && !isset($info['title'])) {
          $info['title'] = $context->theme_section['title'];
        }
        if (!empty($context->theme_section['subtitle']) && !isset($info['subtitle'])) {
          $info['subtitle'] = $context->theme_section['subtitle'];
        }
        if (!empty($context->theme_section['class'])) {
          if (!isset($info['class'])) {
            $info['class'] = $context->theme_section['class'];
          }
          else {
            $info['class'] .= ' '. $context->theme_section['class'];
          }
        }
      }
    }
  }
  return $info;
}

/**
 * Wrapper around menu_navigation_links() that gives themers the option of
 * building navigation links based on an active context trail.
 */
function context_ui_menu_navigation_links($menu_name, $level = 0) {
  // Retrieve original path so we can repair it after our hack.
  $original_path = $_GET['q'];

  // Retrieve the first active menu path found.
  foreach (context_ui_active_contexts() as $context) {
    if (isset($context->menu) && !empty($context->menu) && menu_get_item($context->menu)) {
      menu_set_active_item($context->menu);
      break;
    }
  }

  // Build the links requested
  $links = menu_navigation_links($menu_name, $level);

  // Repair and get out
  menu_set_active_item($original_path);
  return $links;
}

/**
 * DEPRECATED FUNCTIONS ===============================================
 */

/**
 * This function is largely deprecated -- it need not be used for
 * theming $primary_links or $secondary_links any longer in a theme's
 * template.php as this is now handled by context_ui_preprocess_page().
 * 
 * You can still use this function, however, to get context-based
 * active classes on any other link arrays you would like to theme.
 */
function theme_context_ui_links($links, $attributes = array('class' => 'links')) {
  $links = context_ui_menu_set_active($links);

  // Pass modified links onto theme_links() for actual theming duties
  return theme('links', $links, $attributes);
}

/**
 * Deprecated name, now that theme_menu_links() no longer exists.
 * Included for backwards compatibility.
 */
function theme_context_ui_menu_links($links, $attributes = array('class' => 'links')) {
  return theme('context_ui_links', $links, $attributes);
}

/**
 * Provides simple operations (load/insert/update/etc.) on a core context space/key/value definition.
 * This function is deprecated! Use the API functions above -- this wrapper is only provided for
 * backwards-compatibility
 *
 * @param $op
 *   Operation to perform on a context. May be one of load/insert/update/delete.
 * @param $context
 *   A context object. Optionally, can be an integer cid for the "load" operation.
 *
 * @return
 *   If loading, returns a full context item. All other operations return true on success and false on failure.
 */
function context_ui_context($op, $context) {
  switch ($op) {
    case 'load':
      return context_ui_load($context);
    case 'insert':
      return context_ui_save($context);
    case 'update':
      return context_ui_save($context);
    case 'delete':
      return context_ui_delete($context);
  }
}

/**
 * Deprecated -- please use context_ui_invalidate_cache().
 */
function context_ui_rebuild() {
  context_ui_invalidate_cache();
  return context_ui_enabled_contexts();
}
