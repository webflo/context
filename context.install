<?php
// $Id$

/**
 * Implementation of hook_install().
 */
function context_install() {
  drupal_install_schema('context');
}

/**
 * Implementation of hook_uninstall().
 */
function context_uninstall() {
  drupal_uninstall_schema('context');
}

/**
 * Implementation of hook_schema().
 */
function context_schema() {
  $schema = array();
  $schema['context'] = array(
    'description' => 'Storage for normal (user-defined) contexts.',
    'export' => array(
      'key' => 'name',
      'identifier' => 'context',
      'default hook' => 'context_default_contexts',  // Function hook name.
      'status' => 'context_status',
      'api' => array(
        'owner' => 'context',
        'api' => 'context',  // Base name for api include files.
        'minimum_version' => 3,
        'current_version' => 3,
      ),
    ),
    'fields' => array(
      'name' => array(
        'description' => 'The primary identifier for a context.',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => '',
      ),
      'description' => array(
        'description' => 'Description for this context.',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => '',
      ),
      'tag' => array(
        'description' => 'Tag for this context.',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => '',
      ),
      'conditions' => array(
        'description' => 'Serialized storage of all context condition settings.',
        'type' => 'text',
        'serialize' => TRUE,
      ),
      'reactions' => array(
        'description' => 'Serialized storage of all context reaction settings.',
        'type' => 'text',
        'serialize' => TRUE,
      ),
    ),
    'primary key' => array('name'),
  );
  return $schema;
}

/**
 * Update script for context that installs the context schema and migrates
 * any existing context data from deprecated context_ui tables.
 */
function context_update_6001() {
  $ret = array();

  if (!db_table_exists('context')) {
    drupal_install_schema('context');
  }

  if (db_table_exists('context_ui')) {
    // Clear the schema cache and rebuild
    drupal_get_schema(NULL, TRUE);

    // Migrate existing contexts to context table
    $result = db_query("SELECT * FROM {context_ui}");
    while ($context = db_fetch_object($result)) {
      // Load setters
      $setter_result = db_query("SELECT * FROM {context_ui_setter} WHERE cid = %d", $context->cid);
      while ($row = db_fetch_object($setter_result)) {
        $context->{$row->type}[$row->id] = $row->id;
      }
      // Load getters
      $getter_result = db_query("SELECT * FROM {context_ui_getter} WHERE cid = %d", $context->cid);
      while ($row = db_fetch_object($getter_result)) {
        $context->{$row->type} = unserialize($row->data);
      }
      // Load blocks
      $block_result = db_query("SELECT module, delta, region, weight FROM {context_ui_block} WHERE cid = %d", $context->cid);
      while ($block = db_fetch_object($block_result)) {
        if (!isset($context->block)) {
          $context->block = array();
        }
        $block->bid = $block->module ."_". $block->delta;
        $context->block[$block->bid] = $block;
      }
      // Clear out identifier
      unset($context->cid);
      context_save_context($context);
    }
  }

  module_enable(array('context_contrib'));

  return $ret;
}

/**
 * Update script for API change in path condition.
 */
function context_update_6002() {
  define('CONTEXT_STORAGE_DEFAULT', 0);
  define('CONTEXT_STORAGE_OVERRIDDEN', 1);
  define('CONTEXT_STORAGE_NORMAL', 2);

  // Iterate through all DB-stored contexts and incorporate path
  // wildcards into their path conditions. Any exported/default
  // contexts will need to be updated by hand.
  $contexts = context_enabled_contexts();
  foreach ($contexts as $context) {
    if (($context->type == CONTEXT_STORAGE_NORMAL || $context->type == CONTEXT_STORAGE_OVERRIDDEN) && (!empty($context->path) && is_array($context->path))) {
      $changed = FALSE;
      foreach ($context->path as $k => $v) {
        if ($v != '<front>' && strpos($v, '*') === FALSE) {
          $changed = TRUE;
          $context->path[$k] = "{$v}*";
        }
      }
      if ($changed) {
        context_save_context($context);
      }
    }
  }
  return array();
}

/**
 * Remove deprecated tables from context_ui.
 */
function context_update_6003() {
  $ret = array();
  $tables = array('context_ui', 'context_ui_setter', 'context_ui_getter', 'context_ui_block');
  foreach ($tables as $table) {
    if (db_table_exists($table)) {
      db_drop_table($ret, $table);
    }
  }
  return $ret;
}

/**
 * Update 6301: Update schema.
 */
function context_update_6301() {

  $schema = array(
    'fields' => array(
      'name' => array(
        'description' => 'The primary identifier for a context.',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => '',
      ),
      'description' => array(
        'description' => 'Description for this context.',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => '',
      ),
      'tag' => array(
        'description' => 'Tag for this context.',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => '',
      ),
      'conditions' => array(
        'description' => 'Serialized storage of all context condition settings.',
        'type' => 'text',
        'serialize' => TRUE,
      ),
      'reactions' => array(
        'description' => 'Serialized storage of all context reaction settings.',
        'type' => 'text',
        'serialize' => TRUE,
      ),
    ),
    'primary key' => array('name'),
  );

  // Install CTools.
  drupal_install_modules(array('ctools'));

  // Invoke context 2.0 default hooks, write to DB.
  foreach (module_invoke_all('context_default_contexts') as $context) {
    if (is_array($context) && !isset($context['api_version'])) {
      $serialized = $context;
      // Clear out non-condition/reaction attributes
      unset($serialized['namespace'], $serialized['attribute'], $serialized['value'], $serialized['type'], $serialized['status']);
      if (0 == db_result(db_query("SELECT count(*) FROM {context} WHERE namespace = '%s' AND attribute = '%s' AND value = '%s'", $context['namespace'], $context['attribute'], $context['value']))) {
        db_query("INSERT INTO {context}(namespace, attribute, value, data) VALUES('%s', '%s', '%s', '%s')", $context['namespace'], $context['attribute'], $context['value'], serialize($serialized));
      }
    }
  }

  $ret = array();
  if (db_table_exists('context')) {
    $result = db_query("SELECT * FROM {context}");

    // Drop the existing context table and create one using the new schema.
    db_drop_table($ret, 'context');
    db_create_table($ret, 'context', $schema);

    // Migrate old contexts into new table.
    while ($row = db_fetch_object($result)) {
      $data = unserialize($row->data);

      $new = array(
        'name' => "{$row->namespace}_{$row->attribute}_{$row->value}",
        'description' => isset($data['description']) ? $data['description'] : '',
        'tag' => '',
        'conditions' => array(),
        'reactions' => array(),
      );

      // Migration condition/reaction settings.
      $conditions = array('node', 'user', 'book', 'sitewide', 'path', 'menu_trail', 'views', 'nodequeue');
      foreach ($conditions as $key) {
        if (isset($data[$key])) {
          $new['conditions'][$key] = array('values' => $data[$key], 'options' => array());
        }
      }
      $reactions = array('menu', 'theme_section', 'theme_regiontoggle', 'css_injector');
      foreach ($reactions as $key) {
        if (isset($data[$key])) {
          $new['reactions'][$key] = $data[$key];
        }
      }
      // Special treatment for blocks.
      if (isset($data['block'])) {
        foreach ($data['block'] as $block) {
          $block = (array)$block;
          $new['reactions']['block']['blocks'][$block['module'] .'-'. $block['delta']] = $block;
        }
      }
      $new['conditions'] = serialize($new['conditions']);
      $new['reactions'] = serialize($new['reactions']);

      // update_sql does not escape strings properly.
      db_query("INSERT INTO {context} (name,description,tag,conditions,reactions) VALUES ('%s', '%s', '%s', '%s', '%s')", $new['name'], $new['description'], $new['tag'], $new['conditions'], $new['reactions']);
    }
  }
  return $ret;
}
